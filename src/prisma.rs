// Code generated by Prisma Client Rust. DO NOT EDIT.

#![allow(warnings, unused)]
use prisma_client_rust::datamodel::parse_configuration;
use prisma_client_rust::prisma_models::InternalDataModelBuilder;
use prisma_client_rust::query::{
    transform_equals, Field, Input, Output, Query, QueryContext, Result as QueryResult,
};
use prisma_client_rust::query_core::{
    executor, schema_builder, BuildMode, CoreError, InterpreterError, QueryExecutor,
    QueryGraphBuilderError, QuerySchema,
};
use prisma_client_rust::{chrono, operator::Operator, serde_json, CountResult, Direction};
pub use prisma_client_rust::{query::Error as QueryError, NewClientError};
use serde::{Deserialize, Serialize};
use std::path::Path;
use std::sync::Arc;
static DATAMODEL_STR : & 'static str = "datasource db {\n    url = env(\"DATABASE_URL\")\n    provider = \"mysql\"\n    referentialIntegrity = \"prisma\"\n}\n\ngenerator client {\n    provider = \"cargo prisma\"\n    output = \"./src/prisma.rs\"\n    previewFeatures = [\"referentialIntegrity\"]\n}\n\nenum Role {\n    USER\n    ADMIN\n}\n\nmodel User {\n    id Int @id @default(autoincrement())\n    email String @unique\n    username String\n    password String\n    role Role \n    token_version Int @default(1)\n}\n\nmodel Noun {\n    gender String //enum?\n    declension String\n    n_sg String @id @unique\n    g_sg String\n    d_sg String\n    acc_sg String\n    ab_sg String\n    voc_sg String\n    n_pl String\n    g_pl String\n    d_pl String\n    acc_pl String\n    ab_pl String\n    voc_pl String\n    translation String\n    def String\n}" ;
pub struct PrismaClient {
    executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
    query_schema: Arc<QuerySchema>,
}
pub async fn new_client() -> Result<PrismaClient, NewClientError> {
    let config = parse_configuration(DATAMODEL_STR)?.subject;
    let source = config
        .datasources
        .first()
        .expect("Pleasy supply a datasource in your schema.prisma file");
    let url = if let Some(url) = source.load_shadow_database_url()? {
        url
    } else {
        source.load_url(|key| std::env::var(key).ok())?
    };
    let url = if url.starts_with("file:") {
        let path = url.split(":").nth(1).unwrap();
        if Path::new("./schema.prisma").exists() {
            url
        } else if Path::new("./prisma/schema.prisma").exists() {
            format!("file:./prisma/{}", path)
        } else {
            url
        }
    } else {
        url
    };
    new_client_with_url(&url).await
}
pub async fn new_client_with_url(url: &str) -> Result<PrismaClient, NewClientError> {
    let config = parse_configuration(DATAMODEL_STR)?.subject;
    let source = config
        .datasources
        .first()
        .expect("Pleasy supply a datasource in your schema.prisma file");
    let (db_name, executor) = executor::load(&source, &[], &url).await?;
    let internal_model = InternalDataModelBuilder::new(DATAMODEL_STR).build(db_name);
    let query_schema = Arc::new(schema_builder::build(
        internal_model,
        BuildMode::Modern,
        true,
        source.capabilities(),
        vec![],
        source.referential_integrity(),
    ));
    executor.primary_connector().get_connection().await?;
    Ok(PrismaClient {
        executor,
        query_schema,
    })
}
impl PrismaClient {
    pub async fn _query_raw<T: serde::de::DeserializeOwned>(
        &self,
        query: &str,
    ) -> QueryResult<Vec<T>> {
        let query = Query {
            ctx: QueryContext::new(&self.executor, self.query_schema.clone()),
            operation: "mutation".into(),
            method: "queryRaw".into(),
            inputs: vec![
                Input {
                    name: "query".into(),
                    value: Some(query.into()),
                    ..Default::default()
                },
                Input {
                    name: "parameters".into(),
                    value: Some("[]".into()),
                    ..Default::default()
                },
            ],
            name: "".into(),
            model: "".into(),
            outputs: vec![],
        };
        query.perform().await
    }
    pub async fn _execute_raw(&self, query: &str) -> QueryResult<i64> {
        let query = Query {
            ctx: QueryContext::new(&self.executor, self.query_schema.clone()),
            operation: "mutation".into(),
            method: "executeRaw".into(),
            inputs: vec![
                Input {
                    name: "query".into(),
                    value: Some(query.into()),
                    ..Default::default()
                },
                Input {
                    name: "parameters".into(),
                    value: Some("[]".into()),
                    ..Default::default()
                },
            ],
            name: "".into(),
            model: "".into(),
            outputs: vec![],
        };
        query.perform().await.map(|result: i64| result)
    }
    pub fn user(&self) -> user::Actions {
        user::Actions { client: &self }
    }
    pub fn noun(&self) -> noun::Actions {
        noun::Actions { client: &self }
    }
}
pub mod user {
    use super::*;
    pub mod id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: i32) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod email {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::EmailEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Email(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Email(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EmailInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EmailNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::EmailLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::EmailLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::EmailGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::EmailGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::EmailContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::EmailStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::EmailEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::EmailNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEmail(value.0)
            }
        }
    }
    pub mod username {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::UsernameEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Username(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UsernameInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UsernameNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UsernameLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UsernameLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UsernameGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UsernameGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UsernameContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UsernameStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UsernameEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UsernameNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUsername(value.0)
            }
        }
    }
    pub mod password {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::PasswordEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Password(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::PasswordInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::PasswordNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::PasswordLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::PasswordLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::PasswordGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::PasswordGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::PasswordContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::PasswordStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::PasswordEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::PasswordNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetPassword(value.0)
            }
        }
    }
    pub mod role {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Role) -> T {
            Set(value).into()
        }
        pub fn equals(value: Role) -> WhereParam {
            WhereParam::RoleEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Role(direction)
        }
        pub fn in_vec(value: Vec<Role>) -> WhereParam {
            WhereParam::RoleInVec(value)
        }
        pub fn not_in_vec(value: Vec<Role>) -> WhereParam {
            WhereParam::RoleNotInVec(value)
        }
        pub fn not(value: Role) -> WhereParam {
            WhereParam::RoleNot(value)
        }
        pub struct Set(Role);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetRole(value.0)
            }
        }
    }
    pub mod token_version {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::TokenVersionEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::TokenVersion(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementTokenVersion(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementTokenVersion(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyTokenVersion(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideTokenVersion(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::TokenVersionInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::TokenVersionNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::TokenVersionLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::TokenVersionLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::TokenVersionGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::TokenVersionGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::TokenVersionNot(value)
        }
        pub struct Set(i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTokenVersion(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Output> {
        vec![
            Output::new("id"),
            Output::new("email"),
            Output::new("username"),
            Output::new("password"),
            Output::new("role"),
            Output::new("token_version"),
        ]
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "email")]
        pub email: String,
        #[serde(rename = "username")]
        pub username: String,
        #[serde(rename = "password")]
        pub password: String,
        #[serde(rename = "role")]
        pub role: Role,
        #[serde(rename = "token_version")]
        pub token_version: i32,
    }
    impl Data {}
    pub enum WithParam {}
    impl WithParam {
        pub fn to_output(self) -> Output {
            match self {}
        }
    }
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetEmail(String),
        SetUsername(String),
        SetPassword(String),
        SetRole(Role),
        SetTokenVersion(i32),
        IncrementTokenVersion(i32),
        DecrementTokenVersion(i32),
        MultiplyTokenVersion(i32),
        DivideTokenVersion(i32),
    }
    impl SetParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::SetId(value) => Field {
                    name: "id".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::IncrementId(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "increment".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DecrementId(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "decrement".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::MultiplyId(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "multiply".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DivideId(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "divide".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::SetEmail(value) => Field {
                    name: "email".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetUsername(value) => Field {
                    name: "username".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetPassword(value) => Field {
                    name: "password".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetRole(value) => Field {
                    name: "role".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetTokenVersion(value) => Field {
                    name: "token_version".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::IncrementTokenVersion(value) => Field {
                    name: "token_version".into(),
                    fields: Some(vec![Field {
                        name: "increment".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DecrementTokenVersion(value) => Field {
                    name: "token_version".into(),
                    fields: Some(vec![Field {
                        name: "decrement".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::MultiplyTokenVersion(value) => Field {
                    name: "token_version".into(),
                    fields: Some(vec![Field {
                        name: "multiply".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DivideTokenVersion(value) => Field {
                    name: "token_version".into(),
                    fields: Some(vec![Field {
                        name: "divide".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        Email(Direction),
        Username(Direction),
        Password(Direction),
        Role(Direction),
        TokenVersion(Direction),
    }
    impl OrderByParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::Id(direction) => Field {
                    name: "id".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::Email(direction) => Field {
                    name: "email".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::Username(direction) => Field {
                    name: "username".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::Password(direction) => Field {
                    name: "password".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::Role(direction) => Field {
                    name: "role".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::TokenVersion(direction) => Field {
                    name: "token_version".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum Cursor {
        Id(i32),
        Email(String),
        Username(String),
        Password(String),
        Role(Role),
        TokenVersion(i32),
    }
    impl Cursor {
        fn to_field(self) -> Field {
            match self {
                Self::Id(value) => Field {
                    name: "id".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::Email(value) => Field {
                    name: "email".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::Username(value) => Field {
                    name: "username".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::Password(value) => Field {
                    name: "password".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::Role(value) => Field {
                    name: "role".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::TokenVersion(value) => Field {
                    name: "token_version".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(i32),
        IdInVec(Vec<i32>),
        IdNotInVec(Vec<i32>),
        IdLt(i32),
        IdLte(i32),
        IdGt(i32),
        IdGte(i32),
        IdNot(i32),
        EmailEquals(String),
        EmailInVec(Vec<String>),
        EmailNotInVec(Vec<String>),
        EmailLt(String),
        EmailLte(String),
        EmailGt(String),
        EmailGte(String),
        EmailContains(String),
        EmailStartsWith(String),
        EmailEndsWith(String),
        EmailNot(String),
        UsernameEquals(String),
        UsernameInVec(Vec<String>),
        UsernameNotInVec(Vec<String>),
        UsernameLt(String),
        UsernameLte(String),
        UsernameGt(String),
        UsernameGte(String),
        UsernameContains(String),
        UsernameStartsWith(String),
        UsernameEndsWith(String),
        UsernameNot(String),
        PasswordEquals(String),
        PasswordInVec(Vec<String>),
        PasswordNotInVec(Vec<String>),
        PasswordLt(String),
        PasswordLte(String),
        PasswordGt(String),
        PasswordGte(String),
        PasswordContains(String),
        PasswordStartsWith(String),
        PasswordEndsWith(String),
        PasswordNot(String),
        RoleEquals(Role),
        RoleInVec(Vec<Role>),
        RoleNotInVec(Vec<Role>),
        RoleNot(Role),
        TokenVersionEquals(i32),
        TokenVersionInVec(Vec<i32>),
        TokenVersionNotInVec(Vec<i32>),
        TokenVersionLt(i32),
        TokenVersionLte(i32),
        TokenVersionGt(i32),
        TokenVersionGte(i32),
        TokenVersionNot(i32),
    }
    impl WhereParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::Not(value) => Field {
                    name: "NOT".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::Or(value) => Field {
                    name: "OR".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::And(value) => Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::IdEquals(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdInVec(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdNotInVec(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdLt(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdLte(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdGt(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdGte(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdNot(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailEquals(value) => Field {
                    name: "email".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailInVec(value) => Field {
                    name: "email".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailNotInVec(value) => Field {
                    name: "email".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailLt(value) => Field {
                    name: "email".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailLte(value) => Field {
                    name: "email".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailGt(value) => Field {
                    name: "email".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailGte(value) => Field {
                    name: "email".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailContains(value) => Field {
                    name: "email".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailStartsWith(value) => Field {
                    name: "email".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailEndsWith(value) => Field {
                    name: "email".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::EmailNot(value) => Field {
                    name: "email".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UsernameEquals(value) => Field {
                    name: "username".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UsernameInVec(value) => Field {
                    name: "username".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UsernameNotInVec(value) => Field {
                    name: "username".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UsernameLt(value) => Field {
                    name: "username".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UsernameLte(value) => Field {
                    name: "username".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UsernameGt(value) => Field {
                    name: "username".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UsernameGte(value) => Field {
                    name: "username".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UsernameContains(value) => Field {
                    name: "username".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UsernameStartsWith(value) => Field {
                    name: "username".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UsernameEndsWith(value) => Field {
                    name: "username".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UsernameNot(value) => Field {
                    name: "username".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PasswordEquals(value) => Field {
                    name: "password".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PasswordInVec(value) => Field {
                    name: "password".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PasswordNotInVec(value) => Field {
                    name: "password".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PasswordLt(value) => Field {
                    name: "password".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PasswordLte(value) => Field {
                    name: "password".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PasswordGt(value) => Field {
                    name: "password".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PasswordGte(value) => Field {
                    name: "password".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PasswordContains(value) => Field {
                    name: "password".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PasswordStartsWith(value) => Field {
                    name: "password".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PasswordEndsWith(value) => Field {
                    name: "password".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PasswordNot(value) => Field {
                    name: "password".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RoleEquals(value) => Field {
                    name: "role".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RoleInVec(value) => Field {
                    name: "role".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RoleNotInVec(value) => Field {
                    name: "role".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::RoleNot(value) => Field {
                    name: "role".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenVersionEquals(value) => Field {
                    name: "token_version".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenVersionInVec(value) => Field {
                    name: "token_version".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenVersionNotInVec(value) => Field {
                    name: "token_version".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenVersionLt(value) => Field {
                    name: "token_version".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenVersionLte(value) => Field {
                    name: "token_version".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenVersionGt(value) => Field {
                    name: "token_version".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenVersionGte(value) => Field {
                    name: "token_version".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TokenVersionNot(value) => Field {
                    name: "token_version".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
            }
        }
    }
    pub enum UniqueWhereParam {
        IdEquals(i32),
        EmailEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
                UniqueWhereParam::EmailEquals(value) => Self::EmailEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub struct FindMany<'a> {
        query: Query<'a>,
        order_by_params: Vec<OrderByParam>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindMany<'a> {
        pub async fn exec(self) -> QueryResult<Vec<Data>> {
            let Self {
                mut query,
                order_by_params,
                with_params,
            } = self;
            if order_by_params.len() > 0 {
                query.inputs.push(Input {
                    name: "orderBy".into(),
                    fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                    ..Default::default()
                });
            }
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn delete(self) -> DeleteMany<'a> {
            DeleteMany {
                query: Query {
                    operation: "mutation".into(),
                    method: "deleteMany".into(),
                    model: "User".into(),
                    outputs: vec![Output::new("count")],
                    ..self.query
                },
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateMany<'a> {
            self.query.inputs.push(Input {
                name: "data".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            UpdateMany {
                query: Query {
                    operation: "mutation".into(),
                    method: "updateMany".into(),
                    outputs: vec![Output::new("count")],
                    ..self.query
                },
            }
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.order_by_params.push(param);
            self
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
        pub fn skip(mut self, skip: usize) -> Self {
            self.query.inputs.push(Input {
                name: "skip".into(),
                value: Some(serde_json::to_value(skip).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn take(mut self, take: usize) -> Self {
            self.query.inputs.push(Input {
                name: "take".into(),
                value: Some(serde_json::to_value(take).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn cursor(mut self, cursor: Cursor) -> Self {
            self.query.inputs.push(Input {
                name: "cursor".into(),
                fields: vec![cursor.to_field()],
                ..Default::default()
            });
            self
        }
    }
    pub struct FindFirst<'a> {
        query: Query<'a>,
        order_by_params: Vec<OrderByParam>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindFirst<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                order_by_params,
                with_params,
            } = self;
            if order_by_params.len() > 0 {
                query.inputs.push(Input {
                    name: "orderBy".into(),
                    fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                    ..Default::default()
                });
            }
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.order_by_params.push(param);
            self
        }
        pub fn skip(mut self, skip: usize) -> Self {
            self.query.inputs.push(Input {
                name: "skip".into(),
                value: Some(serde_json::to_value(skip).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn take(mut self, take: usize) -> Self {
            self.query.inputs.push(Input {
                name: "take".into(),
                value: Some(serde_json::to_value(take).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn cursor(mut self, cursor: Cursor) -> Self {
            self.query.inputs.push(Input {
                name: "cursor".into(),
                fields: vec![cursor.to_field()],
                ..Default::default()
            });
            self
        }
    }
    pub struct FindUnique<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn delete(self) -> Delete<'a> {
            Delete {
                query: Query {
                    operation: "mutation".into(),
                    method: "deleteOne".into(),
                    model: "User".into(),
                    ..self.query
                },
                with_params: vec![],
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateUnique<'a> {
            self.query.inputs.push(Input {
                name: "data".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            UpdateUnique {
                query: Query {
                    operation: "mutation".into(),
                    method: "updateOne".into(),
                    ..self.query
                },
                with_params: vec![],
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct Create<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> Create<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct UpdateUnique<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> UpdateUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            match query.perform().await {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct UpdateMany<'a> {
        query: Query<'a>,
    }
    impl<'a> UpdateMany<'a> {
        pub async fn exec(self) -> QueryResult<usize> {
            self.query.perform().await.map(|res: CountResult| res.count)
        }
    }
    pub struct Upsert<'a> {
        query: Query<'a>,
    }
    impl<'a> Upsert<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            self.query.perform().await
        }
        pub fn create(
            mut self,
            email: email::Set,
            username: username::Set,
            password: password::Set,
            role: role::Set,
            params: Vec<SetParam>,
        ) -> Self {
            let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
            input_fields.push(SetParam::from(email).to_field());
            input_fields.push(SetParam::from(username).to_field());
            input_fields.push(SetParam::from(password).to_field());
            input_fields.push(SetParam::from(role).to_field());
            self.query.inputs.push(Input {
                name: "create".into(),
                fields: input_fields,
                ..Default::default()
            });
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Self {
            self.query.inputs.push(Input {
                name: "update".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            self
        }
    }
    pub struct Delete<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> Delete<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            match query.perform().await {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct DeleteMany<'a> {
        query: Query<'a>,
    }
    impl<'a> DeleteMany<'a> {
        pub async fn exec(self) -> QueryResult<usize> {
            self.query.perform().await.map(|res: CountResult| res.count)
        }
    }
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            email: email::Set,
            username: username::Set,
            password: password::Set,
            role: role::Set,
            params: Vec<SetParam>,
        ) -> Create {
            let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
            input_fields.push(SetParam::from(email).to_field());
            input_fields.push(SetParam::from(username).to_field());
            input_fields.push(SetParam::from(password).to_field());
            input_fields.push(SetParam::from(role).to_field());
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "mutation".into(),
                method: "createOne".into(),
                model: "User".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "data".into(),
                    fields: input_fields,
                    ..Default::default()
                }],
            };
            Create {
                query,
                with_params: vec![],
            }
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            let param: WhereParam = param.into();
            let fields = transform_equals(vec![param.to_field()]);
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findUnique".into(),
                model: "User".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "where".into(),
                    fields,
                    ..Default::default()
                }],
            };
            FindUnique {
                query,
                with_params: vec![],
            }
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            let where_fields: Vec<Field> =
                params.into_iter().map(|param| param.to_field()).collect();
            let inputs = if where_fields.len() > 0 {
                vec![Input {
                    name: "where".into(),
                    fields: vec![Field {
                        name: "AND".into(),
                        list: true,
                        wrap_list: true,
                        fields: Some(where_fields),
                        ..Default::default()
                    }],
                    ..Default::default()
                }]
            } else {
                Vec::new()
            };
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findFirst".into(),
                model: "User".into(),
                outputs: _outputs(),
                inputs,
            };
            FindFirst {
                query,
                order_by_params: vec![],
                with_params: vec![],
            }
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            let where_fields: Vec<Field> =
                params.into_iter().map(|param| param.to_field()).collect();
            let inputs = if where_fields.len() > 0 {
                vec![Input {
                    name: "where".into(),
                    fields: where_fields,
                    ..Default::default()
                }]
            } else {
                Vec::new()
            };
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findMany".into(),
                model: "User".into(),
                outputs: _outputs(),
                inputs,
            };
            FindMany {
                query,
                order_by_params: vec![],
                with_params: vec![],
            }
        }
        pub fn upsert(&self, param: UniqueWhereParam) -> Upsert {
            let param: WhereParam = param.into();
            let fields = transform_equals(vec![param.to_field()]);
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "mutation".into(),
                method: "upsertOne".into(),
                model: "User".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "where".into(),
                    fields,
                    ..Default::default()
                }],
            };
            Upsert { query }
        }
    }
}
pub mod noun {
    use super::*;
    pub mod gender {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::GenderEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Gender(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::GenderInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::GenderNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::GenderLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::GenderLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::GenderGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::GenderGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::GenderContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::GenderStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::GenderEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::GenderNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetGender(value.0)
            }
        }
    }
    pub mod declension {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::DeclensionEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Declension(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DeclensionInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DeclensionNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::DeclensionLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::DeclensionLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::DeclensionGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::DeclensionGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::DeclensionContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::DeclensionStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::DeclensionEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::DeclensionNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDeclension(value.0)
            }
        }
    }
    pub mod n_sg {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::NSgEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::NSg(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::NSg(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NSgInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NSgNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::NSgLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::NSgLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::NSgGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::NSgGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::NSgContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::NSgStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::NSgEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::NSgNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetNSg(value.0)
            }
        }
    }
    pub mod g_sg {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::GSgEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::GSg(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::GSgInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::GSgNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::GSgLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::GSgLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::GSgGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::GSgGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::GSgContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::GSgStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::GSgEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::GSgNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetGSg(value.0)
            }
        }
    }
    pub mod d_sg {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::DSgEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::DSg(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DSgInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DSgNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::DSgLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::DSgLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::DSgGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::DSgGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::DSgContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::DSgStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::DSgEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::DSgNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDSg(value.0)
            }
        }
    }
    pub mod acc_sg {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::AccSgEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::AccSg(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AccSgInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AccSgNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::AccSgLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::AccSgLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::AccSgGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::AccSgGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::AccSgContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::AccSgStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::AccSgEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::AccSgNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAccSg(value.0)
            }
        }
    }
    pub mod ab_sg {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::AbSgEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::AbSg(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AbSgInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AbSgNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::AbSgLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::AbSgLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::AbSgGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::AbSgGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::AbSgContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::AbSgStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::AbSgEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::AbSgNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAbSg(value.0)
            }
        }
    }
    pub mod voc_sg {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::VocSgEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::VocSg(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::VocSgInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::VocSgNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::VocSgLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::VocSgLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::VocSgGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::VocSgGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::VocSgContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::VocSgStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::VocSgEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::VocSgNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetVocSg(value.0)
            }
        }
    }
    pub mod n_pl {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::NPlEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::NPl(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NPlInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NPlNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::NPlLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::NPlLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::NPlGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::NPlGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::NPlContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::NPlStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::NPlEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::NPlNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetNPl(value.0)
            }
        }
    }
    pub mod g_pl {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::GPlEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::GPl(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::GPlInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::GPlNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::GPlLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::GPlLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::GPlGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::GPlGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::GPlContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::GPlStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::GPlEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::GPlNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetGPl(value.0)
            }
        }
    }
    pub mod d_pl {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::DPlEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::DPl(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DPlInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DPlNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::DPlLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::DPlLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::DPlGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::DPlGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::DPlContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::DPlStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::DPlEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::DPlNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDPl(value.0)
            }
        }
    }
    pub mod acc_pl {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::AccPlEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::AccPl(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AccPlInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AccPlNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::AccPlLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::AccPlLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::AccPlGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::AccPlGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::AccPlContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::AccPlStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::AccPlEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::AccPlNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAccPl(value.0)
            }
        }
    }
    pub mod ab_pl {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::AbPlEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::AbPl(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AbPlInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AbPlNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::AbPlLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::AbPlLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::AbPlGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::AbPlGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::AbPlContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::AbPlStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::AbPlEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::AbPlNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAbPl(value.0)
            }
        }
    }
    pub mod voc_pl {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::VocPlEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::VocPl(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::VocPlInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::VocPlNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::VocPlLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::VocPlLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::VocPlGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::VocPlGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::VocPlContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::VocPlStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::VocPlEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::VocPlNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetVocPl(value.0)
            }
        }
    }
    pub mod translation {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::TranslationEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Translation(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TranslationInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::TranslationNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::TranslationLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::TranslationLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::TranslationGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::TranslationGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::TranslationContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::TranslationStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::TranslationEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::TranslationNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTranslation(value.0)
            }
        }
    }
    pub mod def {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::DefEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Def(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DefInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DefNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::DefLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::DefLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::DefGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::DefGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::DefContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::DefStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::DefEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::DefNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDef(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Output> {
        vec![
            Output::new("gender"),
            Output::new("declension"),
            Output::new("n_sg"),
            Output::new("g_sg"),
            Output::new("d_sg"),
            Output::new("acc_sg"),
            Output::new("ab_sg"),
            Output::new("voc_sg"),
            Output::new("n_pl"),
            Output::new("g_pl"),
            Output::new("d_pl"),
            Output::new("acc_pl"),
            Output::new("ab_pl"),
            Output::new("voc_pl"),
            Output::new("translation"),
            Output::new("def"),
        ]
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "gender")]
        pub gender: String,
        #[serde(rename = "declension")]
        pub declension: String,
        #[serde(rename = "n_sg")]
        pub n_sg: String,
        #[serde(rename = "g_sg")]
        pub g_sg: String,
        #[serde(rename = "d_sg")]
        pub d_sg: String,
        #[serde(rename = "acc_sg")]
        pub acc_sg: String,
        #[serde(rename = "ab_sg")]
        pub ab_sg: String,
        #[serde(rename = "voc_sg")]
        pub voc_sg: String,
        #[serde(rename = "n_pl")]
        pub n_pl: String,
        #[serde(rename = "g_pl")]
        pub g_pl: String,
        #[serde(rename = "d_pl")]
        pub d_pl: String,
        #[serde(rename = "acc_pl")]
        pub acc_pl: String,
        #[serde(rename = "ab_pl")]
        pub ab_pl: String,
        #[serde(rename = "voc_pl")]
        pub voc_pl: String,
        #[serde(rename = "translation")]
        pub translation: String,
        #[serde(rename = "def")]
        pub def: String,
    }
    impl Data {}
    pub enum WithParam {}
    impl WithParam {
        pub fn to_output(self) -> Output {
            match self {}
        }
    }
    pub enum SetParam {
        SetGender(String),
        SetDeclension(String),
        SetNSg(String),
        SetGSg(String),
        SetDSg(String),
        SetAccSg(String),
        SetAbSg(String),
        SetVocSg(String),
        SetNPl(String),
        SetGPl(String),
        SetDPl(String),
        SetAccPl(String),
        SetAbPl(String),
        SetVocPl(String),
        SetTranslation(String),
        SetDef(String),
    }
    impl SetParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::SetGender(value) => Field {
                    name: "gender".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetDeclension(value) => Field {
                    name: "declension".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetNSg(value) => Field {
                    name: "n_sg".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetGSg(value) => Field {
                    name: "g_sg".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetDSg(value) => Field {
                    name: "d_sg".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetAccSg(value) => Field {
                    name: "acc_sg".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetAbSg(value) => Field {
                    name: "ab_sg".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetVocSg(value) => Field {
                    name: "voc_sg".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetNPl(value) => Field {
                    name: "n_pl".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetGPl(value) => Field {
                    name: "g_pl".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetDPl(value) => Field {
                    name: "d_pl".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetAccPl(value) => Field {
                    name: "acc_pl".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetAbPl(value) => Field {
                    name: "ab_pl".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetVocPl(value) => Field {
                    name: "voc_pl".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetTranslation(value) => Field {
                    name: "translation".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetDef(value) => Field {
                    name: "def".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum OrderByParam {
        Gender(Direction),
        Declension(Direction),
        NSg(Direction),
        GSg(Direction),
        DSg(Direction),
        AccSg(Direction),
        AbSg(Direction),
        VocSg(Direction),
        NPl(Direction),
        GPl(Direction),
        DPl(Direction),
        AccPl(Direction),
        AbPl(Direction),
        VocPl(Direction),
        Translation(Direction),
        Def(Direction),
    }
    impl OrderByParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::Gender(direction) => Field {
                    name: "gender".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::Declension(direction) => Field {
                    name: "declension".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::NSg(direction) => Field {
                    name: "n_sg".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::GSg(direction) => Field {
                    name: "g_sg".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::DSg(direction) => Field {
                    name: "d_sg".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::AccSg(direction) => Field {
                    name: "acc_sg".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::AbSg(direction) => Field {
                    name: "ab_sg".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::VocSg(direction) => Field {
                    name: "voc_sg".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::NPl(direction) => Field {
                    name: "n_pl".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::GPl(direction) => Field {
                    name: "g_pl".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::DPl(direction) => Field {
                    name: "d_pl".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::AccPl(direction) => Field {
                    name: "acc_pl".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::AbPl(direction) => Field {
                    name: "ab_pl".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::VocPl(direction) => Field {
                    name: "voc_pl".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::Translation(direction) => Field {
                    name: "translation".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::Def(direction) => Field {
                    name: "def".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum Cursor {
        Gender(String),
        Declension(String),
        NSg(String),
        GSg(String),
        DSg(String),
        AccSg(String),
        AbSg(String),
        VocSg(String),
        NPl(String),
        GPl(String),
        DPl(String),
        AccPl(String),
        AbPl(String),
        VocPl(String),
        Translation(String),
        Def(String),
    }
    impl Cursor {
        fn to_field(self) -> Field {
            match self {
                Self::Gender(value) => Field {
                    name: "gender".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::Declension(value) => Field {
                    name: "declension".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::NSg(value) => Field {
                    name: "n_sg".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::GSg(value) => Field {
                    name: "g_sg".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::DSg(value) => Field {
                    name: "d_sg".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::AccSg(value) => Field {
                    name: "acc_sg".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::AbSg(value) => Field {
                    name: "ab_sg".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::VocSg(value) => Field {
                    name: "voc_sg".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::NPl(value) => Field {
                    name: "n_pl".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::GPl(value) => Field {
                    name: "g_pl".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::DPl(value) => Field {
                    name: "d_pl".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::AccPl(value) => Field {
                    name: "acc_pl".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::AbPl(value) => Field {
                    name: "ab_pl".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::VocPl(value) => Field {
                    name: "voc_pl".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::Translation(value) => Field {
                    name: "translation".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::Def(value) => Field {
                    name: "def".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        GenderEquals(String),
        GenderInVec(Vec<String>),
        GenderNotInVec(Vec<String>),
        GenderLt(String),
        GenderLte(String),
        GenderGt(String),
        GenderGte(String),
        GenderContains(String),
        GenderStartsWith(String),
        GenderEndsWith(String),
        GenderNot(String),
        DeclensionEquals(String),
        DeclensionInVec(Vec<String>),
        DeclensionNotInVec(Vec<String>),
        DeclensionLt(String),
        DeclensionLte(String),
        DeclensionGt(String),
        DeclensionGte(String),
        DeclensionContains(String),
        DeclensionStartsWith(String),
        DeclensionEndsWith(String),
        DeclensionNot(String),
        NSgEquals(String),
        NSgInVec(Vec<String>),
        NSgNotInVec(Vec<String>),
        NSgLt(String),
        NSgLte(String),
        NSgGt(String),
        NSgGte(String),
        NSgContains(String),
        NSgStartsWith(String),
        NSgEndsWith(String),
        NSgNot(String),
        GSgEquals(String),
        GSgInVec(Vec<String>),
        GSgNotInVec(Vec<String>),
        GSgLt(String),
        GSgLte(String),
        GSgGt(String),
        GSgGte(String),
        GSgContains(String),
        GSgStartsWith(String),
        GSgEndsWith(String),
        GSgNot(String),
        DSgEquals(String),
        DSgInVec(Vec<String>),
        DSgNotInVec(Vec<String>),
        DSgLt(String),
        DSgLte(String),
        DSgGt(String),
        DSgGte(String),
        DSgContains(String),
        DSgStartsWith(String),
        DSgEndsWith(String),
        DSgNot(String),
        AccSgEquals(String),
        AccSgInVec(Vec<String>),
        AccSgNotInVec(Vec<String>),
        AccSgLt(String),
        AccSgLte(String),
        AccSgGt(String),
        AccSgGte(String),
        AccSgContains(String),
        AccSgStartsWith(String),
        AccSgEndsWith(String),
        AccSgNot(String),
        AbSgEquals(String),
        AbSgInVec(Vec<String>),
        AbSgNotInVec(Vec<String>),
        AbSgLt(String),
        AbSgLte(String),
        AbSgGt(String),
        AbSgGte(String),
        AbSgContains(String),
        AbSgStartsWith(String),
        AbSgEndsWith(String),
        AbSgNot(String),
        VocSgEquals(String),
        VocSgInVec(Vec<String>),
        VocSgNotInVec(Vec<String>),
        VocSgLt(String),
        VocSgLte(String),
        VocSgGt(String),
        VocSgGte(String),
        VocSgContains(String),
        VocSgStartsWith(String),
        VocSgEndsWith(String),
        VocSgNot(String),
        NPlEquals(String),
        NPlInVec(Vec<String>),
        NPlNotInVec(Vec<String>),
        NPlLt(String),
        NPlLte(String),
        NPlGt(String),
        NPlGte(String),
        NPlContains(String),
        NPlStartsWith(String),
        NPlEndsWith(String),
        NPlNot(String),
        GPlEquals(String),
        GPlInVec(Vec<String>),
        GPlNotInVec(Vec<String>),
        GPlLt(String),
        GPlLte(String),
        GPlGt(String),
        GPlGte(String),
        GPlContains(String),
        GPlStartsWith(String),
        GPlEndsWith(String),
        GPlNot(String),
        DPlEquals(String),
        DPlInVec(Vec<String>),
        DPlNotInVec(Vec<String>),
        DPlLt(String),
        DPlLte(String),
        DPlGt(String),
        DPlGte(String),
        DPlContains(String),
        DPlStartsWith(String),
        DPlEndsWith(String),
        DPlNot(String),
        AccPlEquals(String),
        AccPlInVec(Vec<String>),
        AccPlNotInVec(Vec<String>),
        AccPlLt(String),
        AccPlLte(String),
        AccPlGt(String),
        AccPlGte(String),
        AccPlContains(String),
        AccPlStartsWith(String),
        AccPlEndsWith(String),
        AccPlNot(String),
        AbPlEquals(String),
        AbPlInVec(Vec<String>),
        AbPlNotInVec(Vec<String>),
        AbPlLt(String),
        AbPlLte(String),
        AbPlGt(String),
        AbPlGte(String),
        AbPlContains(String),
        AbPlStartsWith(String),
        AbPlEndsWith(String),
        AbPlNot(String),
        VocPlEquals(String),
        VocPlInVec(Vec<String>),
        VocPlNotInVec(Vec<String>),
        VocPlLt(String),
        VocPlLte(String),
        VocPlGt(String),
        VocPlGte(String),
        VocPlContains(String),
        VocPlStartsWith(String),
        VocPlEndsWith(String),
        VocPlNot(String),
        TranslationEquals(String),
        TranslationInVec(Vec<String>),
        TranslationNotInVec(Vec<String>),
        TranslationLt(String),
        TranslationLte(String),
        TranslationGt(String),
        TranslationGte(String),
        TranslationContains(String),
        TranslationStartsWith(String),
        TranslationEndsWith(String),
        TranslationNot(String),
        DefEquals(String),
        DefInVec(Vec<String>),
        DefNotInVec(Vec<String>),
        DefLt(String),
        DefLte(String),
        DefGt(String),
        DefGte(String),
        DefContains(String),
        DefStartsWith(String),
        DefEndsWith(String),
        DefNot(String),
    }
    impl WhereParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::Not(value) => Field {
                    name: "NOT".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::Or(value) => Field {
                    name: "OR".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::And(value) => Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::GenderEquals(value) => Field {
                    name: "gender".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GenderInVec(value) => Field {
                    name: "gender".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GenderNotInVec(value) => Field {
                    name: "gender".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GenderLt(value) => Field {
                    name: "gender".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GenderLte(value) => Field {
                    name: "gender".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GenderGt(value) => Field {
                    name: "gender".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GenderGte(value) => Field {
                    name: "gender".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GenderContains(value) => Field {
                    name: "gender".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GenderStartsWith(value) => Field {
                    name: "gender".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GenderEndsWith(value) => Field {
                    name: "gender".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GenderNot(value) => Field {
                    name: "gender".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DeclensionEquals(value) => Field {
                    name: "declension".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DeclensionInVec(value) => Field {
                    name: "declension".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DeclensionNotInVec(value) => Field {
                    name: "declension".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DeclensionLt(value) => Field {
                    name: "declension".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DeclensionLte(value) => Field {
                    name: "declension".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DeclensionGt(value) => Field {
                    name: "declension".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DeclensionGte(value) => Field {
                    name: "declension".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DeclensionContains(value) => Field {
                    name: "declension".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DeclensionStartsWith(value) => Field {
                    name: "declension".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DeclensionEndsWith(value) => Field {
                    name: "declension".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DeclensionNot(value) => Field {
                    name: "declension".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NSgEquals(value) => Field {
                    name: "n_sg".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NSgInVec(value) => Field {
                    name: "n_sg".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NSgNotInVec(value) => Field {
                    name: "n_sg".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NSgLt(value) => Field {
                    name: "n_sg".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NSgLte(value) => Field {
                    name: "n_sg".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NSgGt(value) => Field {
                    name: "n_sg".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NSgGte(value) => Field {
                    name: "n_sg".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NSgContains(value) => Field {
                    name: "n_sg".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NSgStartsWith(value) => Field {
                    name: "n_sg".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NSgEndsWith(value) => Field {
                    name: "n_sg".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NSgNot(value) => Field {
                    name: "n_sg".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GSgEquals(value) => Field {
                    name: "g_sg".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GSgInVec(value) => Field {
                    name: "g_sg".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GSgNotInVec(value) => Field {
                    name: "g_sg".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GSgLt(value) => Field {
                    name: "g_sg".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GSgLte(value) => Field {
                    name: "g_sg".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GSgGt(value) => Field {
                    name: "g_sg".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GSgGte(value) => Field {
                    name: "g_sg".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GSgContains(value) => Field {
                    name: "g_sg".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GSgStartsWith(value) => Field {
                    name: "g_sg".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GSgEndsWith(value) => Field {
                    name: "g_sg".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GSgNot(value) => Field {
                    name: "g_sg".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DSgEquals(value) => Field {
                    name: "d_sg".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DSgInVec(value) => Field {
                    name: "d_sg".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DSgNotInVec(value) => Field {
                    name: "d_sg".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DSgLt(value) => Field {
                    name: "d_sg".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DSgLte(value) => Field {
                    name: "d_sg".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DSgGt(value) => Field {
                    name: "d_sg".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DSgGte(value) => Field {
                    name: "d_sg".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DSgContains(value) => Field {
                    name: "d_sg".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DSgStartsWith(value) => Field {
                    name: "d_sg".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DSgEndsWith(value) => Field {
                    name: "d_sg".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DSgNot(value) => Field {
                    name: "d_sg".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccSgEquals(value) => Field {
                    name: "acc_sg".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccSgInVec(value) => Field {
                    name: "acc_sg".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccSgNotInVec(value) => Field {
                    name: "acc_sg".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccSgLt(value) => Field {
                    name: "acc_sg".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccSgLte(value) => Field {
                    name: "acc_sg".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccSgGt(value) => Field {
                    name: "acc_sg".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccSgGte(value) => Field {
                    name: "acc_sg".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccSgContains(value) => Field {
                    name: "acc_sg".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccSgStartsWith(value) => Field {
                    name: "acc_sg".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccSgEndsWith(value) => Field {
                    name: "acc_sg".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccSgNot(value) => Field {
                    name: "acc_sg".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AbSgEquals(value) => Field {
                    name: "ab_sg".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AbSgInVec(value) => Field {
                    name: "ab_sg".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AbSgNotInVec(value) => Field {
                    name: "ab_sg".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AbSgLt(value) => Field {
                    name: "ab_sg".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AbSgLte(value) => Field {
                    name: "ab_sg".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AbSgGt(value) => Field {
                    name: "ab_sg".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AbSgGte(value) => Field {
                    name: "ab_sg".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AbSgContains(value) => Field {
                    name: "ab_sg".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AbSgStartsWith(value) => Field {
                    name: "ab_sg".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AbSgEndsWith(value) => Field {
                    name: "ab_sg".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AbSgNot(value) => Field {
                    name: "ab_sg".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::VocSgEquals(value) => Field {
                    name: "voc_sg".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::VocSgInVec(value) => Field {
                    name: "voc_sg".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::VocSgNotInVec(value) => Field {
                    name: "voc_sg".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::VocSgLt(value) => Field {
                    name: "voc_sg".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::VocSgLte(value) => Field {
                    name: "voc_sg".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::VocSgGt(value) => Field {
                    name: "voc_sg".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::VocSgGte(value) => Field {
                    name: "voc_sg".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::VocSgContains(value) => Field {
                    name: "voc_sg".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::VocSgStartsWith(value) => Field {
                    name: "voc_sg".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::VocSgEndsWith(value) => Field {
                    name: "voc_sg".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::VocSgNot(value) => Field {
                    name: "voc_sg".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NPlEquals(value) => Field {
                    name: "n_pl".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NPlInVec(value) => Field {
                    name: "n_pl".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NPlNotInVec(value) => Field {
                    name: "n_pl".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NPlLt(value) => Field {
                    name: "n_pl".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NPlLte(value) => Field {
                    name: "n_pl".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NPlGt(value) => Field {
                    name: "n_pl".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NPlGte(value) => Field {
                    name: "n_pl".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NPlContains(value) => Field {
                    name: "n_pl".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NPlStartsWith(value) => Field {
                    name: "n_pl".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NPlEndsWith(value) => Field {
                    name: "n_pl".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::NPlNot(value) => Field {
                    name: "n_pl".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GPlEquals(value) => Field {
                    name: "g_pl".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GPlInVec(value) => Field {
                    name: "g_pl".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GPlNotInVec(value) => Field {
                    name: "g_pl".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GPlLt(value) => Field {
                    name: "g_pl".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GPlLte(value) => Field {
                    name: "g_pl".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GPlGt(value) => Field {
                    name: "g_pl".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GPlGte(value) => Field {
                    name: "g_pl".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GPlContains(value) => Field {
                    name: "g_pl".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GPlStartsWith(value) => Field {
                    name: "g_pl".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GPlEndsWith(value) => Field {
                    name: "g_pl".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::GPlNot(value) => Field {
                    name: "g_pl".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DPlEquals(value) => Field {
                    name: "d_pl".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DPlInVec(value) => Field {
                    name: "d_pl".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DPlNotInVec(value) => Field {
                    name: "d_pl".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DPlLt(value) => Field {
                    name: "d_pl".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DPlLte(value) => Field {
                    name: "d_pl".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DPlGt(value) => Field {
                    name: "d_pl".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DPlGte(value) => Field {
                    name: "d_pl".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DPlContains(value) => Field {
                    name: "d_pl".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DPlStartsWith(value) => Field {
                    name: "d_pl".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DPlEndsWith(value) => Field {
                    name: "d_pl".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DPlNot(value) => Field {
                    name: "d_pl".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccPlEquals(value) => Field {
                    name: "acc_pl".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccPlInVec(value) => Field {
                    name: "acc_pl".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccPlNotInVec(value) => Field {
                    name: "acc_pl".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccPlLt(value) => Field {
                    name: "acc_pl".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccPlLte(value) => Field {
                    name: "acc_pl".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccPlGt(value) => Field {
                    name: "acc_pl".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccPlGte(value) => Field {
                    name: "acc_pl".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccPlContains(value) => Field {
                    name: "acc_pl".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccPlStartsWith(value) => Field {
                    name: "acc_pl".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccPlEndsWith(value) => Field {
                    name: "acc_pl".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AccPlNot(value) => Field {
                    name: "acc_pl".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AbPlEquals(value) => Field {
                    name: "ab_pl".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AbPlInVec(value) => Field {
                    name: "ab_pl".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AbPlNotInVec(value) => Field {
                    name: "ab_pl".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AbPlLt(value) => Field {
                    name: "ab_pl".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AbPlLte(value) => Field {
                    name: "ab_pl".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AbPlGt(value) => Field {
                    name: "ab_pl".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AbPlGte(value) => Field {
                    name: "ab_pl".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AbPlContains(value) => Field {
                    name: "ab_pl".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AbPlStartsWith(value) => Field {
                    name: "ab_pl".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AbPlEndsWith(value) => Field {
                    name: "ab_pl".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::AbPlNot(value) => Field {
                    name: "ab_pl".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::VocPlEquals(value) => Field {
                    name: "voc_pl".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::VocPlInVec(value) => Field {
                    name: "voc_pl".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::VocPlNotInVec(value) => Field {
                    name: "voc_pl".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::VocPlLt(value) => Field {
                    name: "voc_pl".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::VocPlLte(value) => Field {
                    name: "voc_pl".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::VocPlGt(value) => Field {
                    name: "voc_pl".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::VocPlGte(value) => Field {
                    name: "voc_pl".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::VocPlContains(value) => Field {
                    name: "voc_pl".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::VocPlStartsWith(value) => Field {
                    name: "voc_pl".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::VocPlEndsWith(value) => Field {
                    name: "voc_pl".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::VocPlNot(value) => Field {
                    name: "voc_pl".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TranslationEquals(value) => Field {
                    name: "translation".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TranslationInVec(value) => Field {
                    name: "translation".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TranslationNotInVec(value) => Field {
                    name: "translation".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TranslationLt(value) => Field {
                    name: "translation".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TranslationLte(value) => Field {
                    name: "translation".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TranslationGt(value) => Field {
                    name: "translation".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TranslationGte(value) => Field {
                    name: "translation".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TranslationContains(value) => Field {
                    name: "translation".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TranslationStartsWith(value) => Field {
                    name: "translation".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TranslationEndsWith(value) => Field {
                    name: "translation".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::TranslationNot(value) => Field {
                    name: "translation".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DefEquals(value) => Field {
                    name: "def".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DefInVec(value) => Field {
                    name: "def".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DefNotInVec(value) => Field {
                    name: "def".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DefLt(value) => Field {
                    name: "def".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DefLte(value) => Field {
                    name: "def".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DefGt(value) => Field {
                    name: "def".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DefGte(value) => Field {
                    name: "def".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DefContains(value) => Field {
                    name: "def".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DefStartsWith(value) => Field {
                    name: "def".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DefEndsWith(value) => Field {
                    name: "def".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DefNot(value) => Field {
                    name: "def".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
            }
        }
    }
    pub enum UniqueWhereParam {
        NSgEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::NSgEquals(value) => Self::NSgEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub struct FindMany<'a> {
        query: Query<'a>,
        order_by_params: Vec<OrderByParam>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindMany<'a> {
        pub async fn exec(self) -> QueryResult<Vec<Data>> {
            let Self {
                mut query,
                order_by_params,
                with_params,
            } = self;
            if order_by_params.len() > 0 {
                query.inputs.push(Input {
                    name: "orderBy".into(),
                    fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                    ..Default::default()
                });
            }
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn delete(self) -> DeleteMany<'a> {
            DeleteMany {
                query: Query {
                    operation: "mutation".into(),
                    method: "deleteMany".into(),
                    model: "Noun".into(),
                    outputs: vec![Output::new("count")],
                    ..self.query
                },
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateMany<'a> {
            self.query.inputs.push(Input {
                name: "data".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            UpdateMany {
                query: Query {
                    operation: "mutation".into(),
                    method: "updateMany".into(),
                    outputs: vec![Output::new("count")],
                    ..self.query
                },
            }
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.order_by_params.push(param);
            self
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
        pub fn skip(mut self, skip: usize) -> Self {
            self.query.inputs.push(Input {
                name: "skip".into(),
                value: Some(serde_json::to_value(skip).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn take(mut self, take: usize) -> Self {
            self.query.inputs.push(Input {
                name: "take".into(),
                value: Some(serde_json::to_value(take).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn cursor(mut self, cursor: Cursor) -> Self {
            self.query.inputs.push(Input {
                name: "cursor".into(),
                fields: vec![cursor.to_field()],
                ..Default::default()
            });
            self
        }
    }
    pub struct FindFirst<'a> {
        query: Query<'a>,
        order_by_params: Vec<OrderByParam>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindFirst<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                order_by_params,
                with_params,
            } = self;
            if order_by_params.len() > 0 {
                query.inputs.push(Input {
                    name: "orderBy".into(),
                    fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                    ..Default::default()
                });
            }
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.order_by_params.push(param);
            self
        }
        pub fn skip(mut self, skip: usize) -> Self {
            self.query.inputs.push(Input {
                name: "skip".into(),
                value: Some(serde_json::to_value(skip).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn take(mut self, take: usize) -> Self {
            self.query.inputs.push(Input {
                name: "take".into(),
                value: Some(serde_json::to_value(take).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn cursor(mut self, cursor: Cursor) -> Self {
            self.query.inputs.push(Input {
                name: "cursor".into(),
                fields: vec![cursor.to_field()],
                ..Default::default()
            });
            self
        }
    }
    pub struct FindUnique<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn delete(self) -> Delete<'a> {
            Delete {
                query: Query {
                    operation: "mutation".into(),
                    method: "deleteOne".into(),
                    model: "Noun".into(),
                    ..self.query
                },
                with_params: vec![],
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateUnique<'a> {
            self.query.inputs.push(Input {
                name: "data".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            UpdateUnique {
                query: Query {
                    operation: "mutation".into(),
                    method: "updateOne".into(),
                    ..self.query
                },
                with_params: vec![],
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct Create<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> Create<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct UpdateUnique<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> UpdateUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            match query.perform().await {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct UpdateMany<'a> {
        query: Query<'a>,
    }
    impl<'a> UpdateMany<'a> {
        pub async fn exec(self) -> QueryResult<usize> {
            self.query.perform().await.map(|res: CountResult| res.count)
        }
    }
    pub struct Upsert<'a> {
        query: Query<'a>,
    }
    impl<'a> Upsert<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            self.query.perform().await
        }
        pub fn create(
            mut self,
            gender: gender::Set,
            declension: declension::Set,
            n_sg: n_sg::Set,
            g_sg: g_sg::Set,
            d_sg: d_sg::Set,
            acc_sg: acc_sg::Set,
            ab_sg: ab_sg::Set,
            voc_sg: voc_sg::Set,
            n_pl: n_pl::Set,
            g_pl: g_pl::Set,
            d_pl: d_pl::Set,
            acc_pl: acc_pl::Set,
            ab_pl: ab_pl::Set,
            voc_pl: voc_pl::Set,
            translation: translation::Set,
            def: def::Set,
            params: Vec<SetParam>,
        ) -> Self {
            let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
            input_fields.push(SetParam::from(gender).to_field());
            input_fields.push(SetParam::from(declension).to_field());
            input_fields.push(SetParam::from(n_sg).to_field());
            input_fields.push(SetParam::from(g_sg).to_field());
            input_fields.push(SetParam::from(d_sg).to_field());
            input_fields.push(SetParam::from(acc_sg).to_field());
            input_fields.push(SetParam::from(ab_sg).to_field());
            input_fields.push(SetParam::from(voc_sg).to_field());
            input_fields.push(SetParam::from(n_pl).to_field());
            input_fields.push(SetParam::from(g_pl).to_field());
            input_fields.push(SetParam::from(d_pl).to_field());
            input_fields.push(SetParam::from(acc_pl).to_field());
            input_fields.push(SetParam::from(ab_pl).to_field());
            input_fields.push(SetParam::from(voc_pl).to_field());
            input_fields.push(SetParam::from(translation).to_field());
            input_fields.push(SetParam::from(def).to_field());
            self.query.inputs.push(Input {
                name: "create".into(),
                fields: input_fields,
                ..Default::default()
            });
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Self {
            self.query.inputs.push(Input {
                name: "update".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            self
        }
    }
    pub struct Delete<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> Delete<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            match query.perform().await {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct DeleteMany<'a> {
        query: Query<'a>,
    }
    impl<'a> DeleteMany<'a> {
        pub async fn exec(self) -> QueryResult<usize> {
            self.query.perform().await.map(|res: CountResult| res.count)
        }
    }
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            gender: gender::Set,
            declension: declension::Set,
            n_sg: n_sg::Set,
            g_sg: g_sg::Set,
            d_sg: d_sg::Set,
            acc_sg: acc_sg::Set,
            ab_sg: ab_sg::Set,
            voc_sg: voc_sg::Set,
            n_pl: n_pl::Set,
            g_pl: g_pl::Set,
            d_pl: d_pl::Set,
            acc_pl: acc_pl::Set,
            ab_pl: ab_pl::Set,
            voc_pl: voc_pl::Set,
            translation: translation::Set,
            def: def::Set,
            params: Vec<SetParam>,
        ) -> Create {
            let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
            input_fields.push(SetParam::from(gender).to_field());
            input_fields.push(SetParam::from(declension).to_field());
            input_fields.push(SetParam::from(n_sg).to_field());
            input_fields.push(SetParam::from(g_sg).to_field());
            input_fields.push(SetParam::from(d_sg).to_field());
            input_fields.push(SetParam::from(acc_sg).to_field());
            input_fields.push(SetParam::from(ab_sg).to_field());
            input_fields.push(SetParam::from(voc_sg).to_field());
            input_fields.push(SetParam::from(n_pl).to_field());
            input_fields.push(SetParam::from(g_pl).to_field());
            input_fields.push(SetParam::from(d_pl).to_field());
            input_fields.push(SetParam::from(acc_pl).to_field());
            input_fields.push(SetParam::from(ab_pl).to_field());
            input_fields.push(SetParam::from(voc_pl).to_field());
            input_fields.push(SetParam::from(translation).to_field());
            input_fields.push(SetParam::from(def).to_field());
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "mutation".into(),
                method: "createOne".into(),
                model: "Noun".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "data".into(),
                    fields: input_fields,
                    ..Default::default()
                }],
            };
            Create {
                query,
                with_params: vec![],
            }
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            let param: WhereParam = param.into();
            let fields = transform_equals(vec![param.to_field()]);
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findUnique".into(),
                model: "Noun".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "where".into(),
                    fields,
                    ..Default::default()
                }],
            };
            FindUnique {
                query,
                with_params: vec![],
            }
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            let where_fields: Vec<Field> =
                params.into_iter().map(|param| param.to_field()).collect();
            let inputs = if where_fields.len() > 0 {
                vec![Input {
                    name: "where".into(),
                    fields: vec![Field {
                        name: "AND".into(),
                        list: true,
                        wrap_list: true,
                        fields: Some(where_fields),
                        ..Default::default()
                    }],
                    ..Default::default()
                }]
            } else {
                Vec::new()
            };
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findFirst".into(),
                model: "Noun".into(),
                outputs: _outputs(),
                inputs,
            };
            FindFirst {
                query,
                order_by_params: vec![],
                with_params: vec![],
            }
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            let where_fields: Vec<Field> =
                params.into_iter().map(|param| param.to_field()).collect();
            let inputs = if where_fields.len() > 0 {
                vec![Input {
                    name: "where".into(),
                    fields: where_fields,
                    ..Default::default()
                }]
            } else {
                Vec::new()
            };
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findMany".into(),
                model: "Noun".into(),
                outputs: _outputs(),
                inputs,
            };
            FindMany {
                query,
                order_by_params: vec![],
                with_params: vec![],
            }
        }
        pub fn upsert(&self, param: UniqueWhereParam) -> Upsert {
            let param: WhereParam = param.into();
            let fields = transform_equals(vec![param.to_field()]);
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "mutation".into(),
                method: "upsertOne".into(),
                model: "Noun".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "where".into(),
                    fields,
                    ..Default::default()
                }],
            };
            Upsert { query }
        }
    }
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum Role {
    #[serde(rename = "USER")]
    User,
    #[serde(rename = "ADMIN")]
    Admin,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum UserScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
    #[serde(rename = "email")]
    Email,
    #[serde(rename = "username")]
    Username,
    #[serde(rename = "password")]
    Password,
    #[serde(rename = "role")]
    Role,
    #[serde(rename = "token_version")]
    TokenVersion,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum NounScalarFieldEnum {
    #[serde(rename = "gender")]
    Gender,
    #[serde(rename = "declension")]
    Declension,
    #[serde(rename = "n_sg")]
    NSg,
    #[serde(rename = "g_sg")]
    GSg,
    #[serde(rename = "d_sg")]
    DSg,
    #[serde(rename = "acc_sg")]
    AccSg,
    #[serde(rename = "ab_sg")]
    AbSg,
    #[serde(rename = "voc_sg")]
    VocSg,
    #[serde(rename = "n_pl")]
    NPl,
    #[serde(rename = "g_pl")]
    GPl,
    #[serde(rename = "d_pl")]
    DPl,
    #[serde(rename = "acc_pl")]
    AccPl,
    #[serde(rename = "ab_pl")]
    AbPl,
    #[serde(rename = "voc_pl")]
    VocPl,
    #[serde(rename = "translation")]
    Translation,
    #[serde(rename = "def")]
    Def,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum SortOrder {
    #[serde(rename = "asc")]
    Asc,
    #[serde(rename = "desc")]
    Desc,
}
